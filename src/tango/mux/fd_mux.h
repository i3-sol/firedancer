#ifndef HEADER_fd_src_tango_mux_fd_mux_h
#define HEADER_fd_src_tango_mux_fd_mux_h

/* fd_mux provides services to multiplex multiple streams of input
   fragments and present them to a mix of reliable and unreliable
   consumers as though they were generated by a signal producer.  The
   entire process is zero copy for the actual fragment payloads and thus
   has extremely high throughput and extremely high scalability. */

#include "../tempo/fd_tempo.h"
#include "../cnc/fd_cnc.h"
#include "../fseq/fd_fseq.h"
#include "../fctl/fd_fctl.h"
#include "../mcache/fd_mcache.h"

#if FD_HAS_HOSTED && FD_HAS_X86 && FD_HAS_ALLOCA

/* Beyond the standard FD_CNC_SIGNAL_HALT, FD_MUX_CNC_SIGNAL_ACK can be
   raised by a cnc thread with an open command session while the mux is
   in the RUN state.  The mux will transition from ACK->RUN the next
   time it processes cnc signals to indicate it is running normally.  If
   a signal other than ACK, HALT, or RUN is raised, it will be logged as
   unexpected and transitioned by back to RUN. */

#define FD_MUX_CNC_SIGNAL_ACK (4UL)

/* The mux will use the application region of the fseqs for accumulating
   various diagnostics related to flow control.  Treating the application
   region was an array of ulongs, we have the diagnostics:

     PUB_CNT   is the number of input fragments published by the mux
     PUB_SZ    is the number of input fragment payload bytes published by the mux
     FILT_CNT  is the number of input fragments filtered by the mux
     FILT_SZ   is the number of input fragment payload bytes filtered by the mux

   For input fseqs:
     OVRNP_CNT is the number of input overruns detected while polling for metadata by the mux
     OVRNR_CNT is the number of input overruns detected while reading metadata by the mux
     SLOW_CNT is the number of times the mux was detected as throughput limiting by the input

   and for output fseqs:
     OVRNP_CNT is the number of input overruns detected while polling for metadata by the out
     OVRNR_CNT is the number of input overruns detected while reading metadata by the out
     SLOW_CNT is the number of times the output was detected as throughput limiting by the mux

   For input fseqs, the mux tile will accumulate PUB_CNT, PUB_SZ,
   FILT_CNT, FILT_SZ, OVRNP_CNT, and OVRNR_CNT while the input will
   accumulate SLOW_CNT and is free to use counters 7:11 in an
   application specific way.

   For output fseqs, the mux tile will accumulate SLOW_CNT while the
   output ideally will accumulate OVRNP_CNT and OVRNR_CNT (and
   potentially also {PUB,FILT}_{CNT,SZ} if only for monitoring
   simplicity / consistency).  The output is free to use counters 7:11
   in an application specific way.

   It is worth noting that, given proper flow control configuration:
     OVRNP_CNT==OVRNR_CNT==0
     PUB_CNT+FILT_CNT==RX_CNT==TX_CNT
     PUB_SZ +FILT_SZ ==RX_SZ ==TX_SZ
   so there isn't much utility adding additional counters for RX_CNT,
   RX_SZ, TX_CNT and/or TX_SZ as these can be strictly derived from the
   counters that are already there under normal operating conditions and
   abnormal operating conditions can be detected.
   
   Similarly, the mux's cnc application region is used for holding
   additional diagnostics.  Treating the application region as an array
   of ulongs, we have the diagnostics:

     IN_BACKP is 1 if the mux tile is currently waiting for credits from
     outputs to continuing publish.

     BACKP_CNT is the number of tiles the mux tile had to wait for credits
     from outputs to publish.

   Except for IN_BACKP, none of the fields are cleared at tile startup
   (as such that they can be accumulated over multiple runs).  Clearing
   is up to monitoring scripts.  It is recommend that ins also use their
   cnc application regions similarly for monitoring simplicity /
   consistency. */

#define FD_MUX_FSEQ_DIAG_PUB_CNT   (0UL) /* On the 1st fseq cache line, updated by MUX (in fseq) / OUT (out fseq), frequently */
#define FD_MUX_FSEQ_DIAG_PUB_SZ    (1UL) /* " */
#define FD_MUX_FSEQ_DIAG_FILT_CNT  (2UL) /* " */
#define FD_MUX_FSEQ_DIAG_FILT_SZ   (3UL) /* " */
#define FD_MUX_FSEQ_DIAG_OVRNP_CNT (4UL) /* On the 2nd fseq cache line, updated by MUX (in fseq) / OUT (out fseq), ideally never */
#define FD_MUX_FSEQ_DIAG_OVRNR_CNT (5UL) /* " */
#define FD_MUX_FSEQ_DIAG_SLOW_CNT  (6UL) /* ", updated by IN (in fseq) / MUX (out fseq), rarely */

#define FD_MUX_CNC_DIAG_IN_BACKP   (0UL) /* updated by MUX (and TX), ideally never */
#define FD_MUX_CNC_DIAG_BACKP_CNT  (1UL) /* updated by MUX (and TX), ideally never */

/* FD_MUX_TILE_IN_MAX and FD_MUX_TILE_OUT_MAX are the maximum number of
   inputs and outputs respectively that a mux tile can have.  These
   limits are more or less arbitrary from a functional correctness POV.
   They mostly exist to set some practical upper bounds for things like
   scratch footprint.  The current value for IN_MAX is large enough to
   have every possible frag meta origin be handled by a single thread.
   (And out_max is set arbitrarily to match.) */

#define FD_MUX_TILE_IN_MAX  FD_FRAG_META_ORIG_MAX
#define FD_MUX_TILE_OUT_MAX FD_FRAG_META_ORIG_MAX

/* FD_MUX_TILE_SCRATCH_{ALIGN,FOOTPRINT} specify the alignment and
   footprint needed for a mux tile scratch region that can support
   in_cnt inputs and out_cnt outputs.  ALIGN is an integer power of 2 of
   at least be at least double cache line to mitigate various kinds of
   false sharing.  FOOTPRINT will be an integer multiple of ALIGN.
   {in,out}_cnt are assumed to be valid (i.e. at most
   FD_MUX_TILE_{IN,OUT}_MAX).  These are provided to facilitate compile
   time declarations. */

#define FD_MUX_TILE_SCRATCH_ALIGN     (128UL)
#define FD_MUX_TILE_SCRATCH_FOOTPRINT( in_cnt, out_cnt )                                                       \
  ( ( (((in_cnt)*66UL + (out_cnt)*26UL + 2UL + FD_RNG_ALIGN-1UL) & (~(FD_RNG_ALIGN-1UL))) + FD_RNG_FOOTPRINT + \
      FD_MUX_TILE_SCRATCH_ALIGN-1UL ) & (~(FD_MUX_TILE_SCRATCH_ALIGN-1UL)) )

FD_PROTOTYPES_BEGIN

/* fd_mux_tile runs a frag stream multiplexer on the caller's tile.

   The tile will multiplex in_cnt fragment streams to fctl_cnt reliable
   consumers and an arbitrary number of unreliable consumers.  While
   reliable consumers are simple to reason about, they have especially
   high demands on their implementation as a single slow reliable
   consumer can backpressure _all_ producers and _all_ consumers using
   the mux.

   When this is called, the cnc should be in the BOOT state.  Returns 0
   on a successful run of the mux tile.  That is, the tile booted
   successfully (transitioning the cnc from BOOT->RUN), ran (handling
   any application specific cnc signals while running), and (after
   receiving a HALT signal) halted successfully (transitioning the cnc
   from HALT->BOOT before return).  Returns a non-zero error code if the
   tile fails to boot up (logs details ... the cnc will not be
   transitioned from its original state and thus is likely bootable
   again if its original state was BOOT).  For maximally robust
   operation in the current implementation, all reliable consumers
   should be halted and/or caught up before this tile is halted.

   There are no theoretical restrictions on the fragment stream mcache
   depths.  Practically, it is recommend these be as large as possible,
   especially for bursty streams and/or a large number of reliable
   consumers.  Likewise, there is no benefit from the mux's POV to using
   a mux_mcache depth different from the smallest in mcache depth
   (smaller can underutilize the input mcaches and larger cannot be
   fully utilized by the downstream outs due to the worst case scenarios
   with the smallest in mcache).  Similarly, there is no advantage from
   the mux's POV to using variable in_mcache depths.  But there can be
   unrelated reasons for variable mcache depths (e.g.  hardware
   requirements for a frag stream produced by custom hardware, needs for
   non-mux consumers of individual frag streams, etc).

   This implementation currently assumes all mcache used have the same
   chunk indexing scheme.  E.g. all the mcache live in the same wksp and
   use the base of the wksp as the reference point for their chunk
   indexing.

   Note that a number of tricks can be done to facilitate making this
   work with completely unreliable communications from producer to mux
   and mux to consumer.  The most efficient trick being that producers
   tag their payloads uniquely and include that tag in metadata (e.g.
   use the signature).  When an unreliable consumer reads the metadata
   from the mux mcache, it learns the tag and then can read the payload
   from the in dcache (no communication links need to be reliable in
   this regime and no verification read of the metadata is required
   either ... does require a tagging method, payload formatting
   requirements and using up some metadata signature bits).  This is
   currently not done in the interest of generality.

   The mux tile will resequence the frags from the various inputs.  No
   frags will be lost from any stream given the above.  The ordering of
   frags from a given input will be preserved as well.  Frags from
   different streams can be arbitrarily interleaved but this makes a
   best effort to avoid starvation and minimize slip between different
   streams.  The tspub field will be overriden by the mux.  Applications
   should use the tsorig field to tag the original origin of packets
   (such that at any given time the tsorig field uniquely identifies an
   active logical publisher and can be used to reconstruct multiple
   fragment messages from that logical publisher).

   mux_cr_max is the maximum number of flow control credits the mux tile
   is allowed for publishing frags to outs.  It represents the maximum
   number of frags a reliable out can to lag behind the mutiplexed
   stream and the maximum number of frags from any in mcache that might
   be exposed to the outs.  In the general case, the optimal value is
   usually to set it to min(in[*].cr_max,out[*].lag_max).  Noting that
   in[*].cr_max is in [1,in[*].depth] and out[*].lag_max is in
   [1,mux.depth], mux_cr_max must be in [1,min(in[*].depth,mux.depth)]
   (and possible tighter).  If mux_cr_max is zero, this use a default of
   mux_cr_max=min(in[*].depth,mux.depth).  This is equivalent to
   assuming, as is typically the case, outs are allowed to lag the mux
   by up mux.depth frags and in[*].cr_max is the same as in[*].depth.

   lazy is the ballpark interval in for how often to receive credits
   from an out (and, equivalently, how often to return credits to an
   in).  Too small a lazy will drown the system in cache coherence
   traffic.  Too lazy a lazy will system throughput because of producers
   are stalled waiting for credits.  lazy should be roughly proportional
   to mux_cr_max and the constant of proportionality should be less than
   how fast a consumer can process frags, ignoring lighthousing under
   the hood.  <=0 indicates to pick a conservative default.

   fd_mux_tile_scratch_align and fd_mux_tile_scratch_footprint return
   the required alignment and footprint needed for this region.  This
   memory region is exclusively owned by the mux tile while the tile is
   running and is ideally near the core running the mux tile.
   fd_mux_tile_scratch_align will return the same value as
   FD_MUX_TILE_SCRATCH_ALIGN.  If (in_cnt,out_cnt) is not valid,
   fd_mux_tile_scratch_footprint silently returns 0 so callers can
   diagnose configuration issues.  Otherwise,
   fd_mux_tile_scratch_footprint will return the same value as
   FD_MUX_TILE_SCRATCH_FOOTPRINT. */

FD_FN_CONST ulong
fd_mux_tile_scratch_align( void );

FD_FN_CONST ulong
fd_mux_tile_scratch_footprint( ulong in_cnt,
                               ulong out_cnt );

int
fd_mux_tile( ulong         in_cnt,      /* Number of input frag streams to multiplex, streams are indexed [0,in_cnt) */
             ulong         out_cnt,     /* Number of reliable consumers, reliable consumers are indexed [0,out_cnt) */
             char const *  _cnc,        /* Workspace gaddr for mux's command-and-control communications */
             char const ** _in_mcache,  /* _in_mcache[in_idx] is the workspace gaddr for input in_idx's mcache */
             char const ** _in_fseq,    /* _in_fseq  [in_idx] is the workspace gaddr for input in_idx's fseq */
             char const *  _mux_mcache, /* Workspace gaddr for mcache of the multiplexed frag streams */
             ulong         mux_cr_max,  /* Maximum number of flow control credits, 0 means use a reasonable default */
             char const ** _out_fseq,   /* _out_fseq [out_idx] is the workspace gaddr for reliable consumer out_idx's fseq */
             long          lazy,        /* Lazyiness, <=0 means use a reasonable default */
             uint          seed,        /* Random number generator seed */
             void *        scratch );   /* Tile scratch memory */

FD_PROTOTYPES_END

#endif

#endif /* HEADER_fd_src_tango_mux_fd_mux_h */

